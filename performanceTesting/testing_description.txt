Immediate Tasks:

  - given the fix to inefficiency in constructing OCaml representation of a solution
    a quick test using a simple example such as reverse should be done to see if
	the time necessary for this processing step still swamps everything else
	
  - test framework for collecting data about twelf should be restructured as laid
    out in the discussion below and re-run to collect the required data for all
	examples
	
  - for example queries shorter than 1s to solve, determine either new queries or
    a modified testing structure to make times more significant
	
  - finish testing all the example signatures
  
  
  

Goal: Build an argument that the translation based approach provides better performance
Why: To support this approach and the theoretical results in a paper/the thesis

A related question of interest:
  What is the impact of translating and iverting on the cost of a
  query?

  In other words, how significant is the impact of these processing
  steps on the time required for our system to solve a query?

Define better performance:
  [GN: This part should provide the rationale for what you are
  measuring, leave the details to the next one. See comments below.]

  1. Our system requires some overhead in handling the signature as it
     must get translated and then the translated files loaded into
     Teyjus. Because this overhead cost is expected to be amortized
     over many queries we will check the overhead time separately and
     only show that it is reasonable.

  2. We will also compare the solving time for a collection of queries
     relative to particular signatures. Our system involves
     translating between a C representation and an OCaml
     representation in order to then perform the inversion and
     printing steps. This step can be costly, but a better
     implementation could be done completely in C. Such an
     implementation would be able to be at least as efficient as the
     inversion and printing functions implemented in OCaml and so we
     will ignore the time to convert from C to OCaml in our query
     solving time.

     
What information will we need for this?

  1. A suitible collection of example signatures and related queries

  2a. How long is needed to do setup in our system
  2b. How long is needed to do setup in Twelf
      (essentially just parsing the specification)

  3a. How long is needed to solve each query in our system given each
      version of the translation
      
      To answer the additional question stated above, this will be
      broken down into timing information for the various steps of
      solving a query. However, in the end any comparisons will be on
      the total time.
  3b. How long is needed to solve each query in Twelf
  
Selection of example specifications and queries:

  The examples will be selected to cover a veriety of potential
  applications of LF logic programming. Because an example consists of
  both a specification and a particular sort of query, a single LF
  signature may be used in multiple examples.

  set of examples:
  
    1. naive reverse of a list
       This is an example of vanilla logic programming.

    2. evaluation of expressions in mini-ml language
       This is an example of an encoding of an evaluator for a
       language. It is deterministic and involves reduction.

    3. type checking of expressions in miniml
       This example makes use of HOAS, is deterministinc, and most of
       the work invovled is evaluation.

    4. evaluation of expressions in a typed encoding of mini-ml language
       This is another example of an evaluator for a language. It
       makes use of dependencies in types.

    5. transformation of simple numerical expressions
       This is an example of an application in which search plays an
       important role but unification is very simple. This example
       also makes use of dependencies in types to encode proofs that
       the two numerical expressions are equal.

    6. list permutation in INCLL
       This is an example of encoding a meta-interpreter for a
       logic. Search and unification both play a role in this
       example.
       ***I am still unsure about the role of unification
          here. Requires more time understanding the example.

    7. cps conversion of expressions
       This is an example where search does not play much of a role
       but there is more than just simple unification involved in
       constructing the transformed expression.

How will we collect this information?  
  in Twelf:
    The twelf system has timers which time various aspects. The
    aspects relevant to the data we collect are: Parsing,
    Reconstructing, Solving, and Printing.

    Note: According to the Users Guide, there is an issue with the
    timing of printing in that it is counted in both the solving and
    printing timers. The design for testing takes this into account by
    getting the timing data for solving and for printing separately so
    that the time for solving is not artificially inflated by the
    inclusion of printing.
	
	1. load base signature file in Twelf and return the total time for
	   Parsing and Reconstruction
	   
	2. set Twelf print depth to 0 (to avoid printing
	   solutions). Then reset the timers and load a second file
	   containing the query to solve and return the total time for
	   parsing, reconstruction, and solving.

        3. set the print depth to *. Then reset the timers and load
	   the query again. Return the total time for printing.
  
  in Tjtwelf:
    Since we did not build in any timers we will use the OCaml
    Sys.time function to determine the processor time used by the
    program and compare before and after the part being timed. This
    process will be performed for each version of the translation.
	
	1. run tjtwelf with the base signature and collect the
	   overhead time.
           (parsing, reconstruction, translation, and setting up the simulator)
	   
	2. run tjtwelf in batch mode providing each query which corresponds to the
	   particular signature and collect the time for solving each query.
           (parsing, type reconstruction, translation, setting up
	   query in the simulator, solving, inversion, and printing)
  

