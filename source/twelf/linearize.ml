(** linearization of translated clauses (restricted Lambda Prolog) **)

(* makeApp: takes a head term `h' and a list of argument terms `a1', `a2', ..., `an' 
            and returns an application term `(((h a1) a2) ... an)'
*)
let makeApp h args =
  List.fold_left (fun t a -> Absyn.ApplicationTerm(Absyn.CurriedApplication(t,a),Errormsg.none))
                 h
                 args
(* makeImp: given terms for left and right side of implication, 
   construct an application term representing (imp left right). *)
let makeImp l r =
  makeApp (Absyn.ConstantTerm(Pervasive.implConstant, [], Errormsg.none)) [l;r]

(* makeAll: given a typesymbol and a body, create an universall 
   quantification over that symbol with the supplied term as the 
   body. *)
let makeAll tysymb body =
  makeApp (Absyn.ConstantTerm(Pervasive.allConstant, [], Errormsg.none))
          [Absyn.AbstractionTerm(Absyn.NestedAbstraction(tysymb, body), Errormsg.none)]
    
(* makeEqn : Absyn.atypesymbol -> Absyn.atypesymbol -> Absyn.aterm
   given two variables x and y, produces the term form of equality for 
   these variables (x = y) *)
let makeEqn x y =
  makeApp (Absyn.ConstantTerm(Pervasive.eqConstant, [], Errormsg.none))
          [Absyn.makeBoundVarTerm x Errormsg.none;
           Absyn.makeBoundVarTerm y Errormsg.none]
    
(* finalize : Absyn.atypesymbol list -> Absyn.aterm list -> 
              Absyn.aterm -> Absyn.aterm
   given (1) a list of newly introduced variables, (2) a list of terms 
         representing the equalies on variables to be added, and (3) 
         the base term to be extended
   returns the final modified term representing a clause.

   eg. 
   finalize (x_1,...,x_n) ((y_1=z_1),...,(y_m=z_m)) t 
   will be the term
   all x_1 ... all x_n (y_1 = z_1) -> ... -> (y_m = z_m) -> t *)
let finalize newvars eqns t =
  List.fold_left (fun tm tysymb -> makeAll tysymb tm)
                 (List.fold_left (fun tm eq -> makeImp eq tm) t eqns)
                 newvars

(* new_var : Absyn.atypesymbol Table.SymbolTable.t -> 
             Absyn.atypesymbol Table.SymbolTable.t -> 
             Absyn.atypesymbol list -> Absyn.atypesymbol -> Absyn.atypesymbol
   given (1) the universally quantified variables in scope, (2) the 
         other variables in scope, (3) any other new variables that 
         have been generated, and (4) the variable to be replaced
   will return a new type symbol for a fresh variable.

   used to generate new variables when more than one occurence of a 
   universal variable is found. The various input values ensure we can 
   choose a name which does not clash with anything else that will be 
   in scope. *)
let new_var uvars bvars newvars (Absyn.BoundVar(s, hc, tysy, ty)) =
  let check_table s tbl =
    Option.isSome (Table.find s tbl)
  in
  let check_list s lst =
    List.exists (fun tysymb -> (Absyn.getTypeSymbolSymbol tysymb) = s) lst
  in
  let rec aux s i =
    let s' = Symbol.symbol (s ^ (string_of_int i)) in
    if (check_table s' uvars) || (check_table s' bvars)
                             || (check_list s' newvars)
    then aux s (i+1)
    else s'
  in
  Absyn.BoundVar(aux (Symbol.name s) 1, hc, tysy, ty)
    
(* lh_t : Absyn.atypesymbol Table.SymbolTable.t -> Absyn.atypesymbol Table.SymbolTable.t -> 
          Absyn.atypesymbol Table.SymbolTable.t -> Absyn.atypesymbol list ->
          Absyn.aterm -> (Absyn.atypesymbol Table.SymbolTable.t * Absyn.atypesymbol
          list * Absyn.aterm * Absyn.aterm list)
   given (1) the universally quantified variables, (2) the subset of
          (1) which have already been seen, (3) the other variables in
          scope, (4) the new variables that have been introduced thus
          far, and (5) the term to be modified such that each variable
          only appears once
   returns (1) an updated list of the universally quantified vraiables
          which have been seen, (2) an updated list of any new
          variables that have been introduced, (3) the modified term,
          and (4) a list of terms representing the equalities on
          variables required by the transformation. *)
let rec lh_t uvars seen bvars newvars t =
  match t with
  (* only nested abstractions are generated by the translation *)
  | Absyn.AbstractionTerm(Absyn.NestedAbstraction(tysymb,body),_) ->
    let (seen', newvars', body', eqns) =
      lh_t uvars seen (Table.add (Absyn.getTypeSymbolSymbol tysymb) tysymb bvars) newvars body
    in
    (seen', newvars',
     Absyn.AbstractionTerm(Absyn.NestedAbstraction(tysymb,body'),Errormsg.none),
     eqns)
  (* only curried applications are generated by the translation *)
  | Absyn.ApplicationTerm(Absyn.CurriedApplication(t1,t2),_) ->
    let (seen1, newvars1, t1', eqns1) =
      lh_t uvars seen bvars newvars t1
    in
    let (seen2, newvars2, t2', eqns2) =
      lh_t uvars seen1 bvars newvars1 t2
    in
    (seen2, newvars2,
     Absyn.ApplicationTerm(Absyn.CurriedApplication(t1',t2'),Errormsg.none),
     (* we want equations in reverse order only while teyjus code solves 
        implications in reverse order. *)
     eqns2 @ eqns1)
  (* only named bound vars are generated by the translation *)
  | Absyn.BoundVarTerm(Absyn.NamedBoundVar(tysymb),_) ->
    let symb = Absyn.getTypeSymbolSymbol tysymb in
    if (Option.isSome (Table.find symb bvars))
    then
      (seen,newvars,t,[])
    else
      (if Option.isSome (Table.find symb uvars)
       then
          (if (Option.isSome (Table.find symb seen))
           then
              let newtysymb = new_var uvars bvars newvars tysymb in
              (seen,
               (newtysymb :: newvars),
               Absyn.makeBoundVarTerm newtysymb Errormsg.none,
               [makeEqn tysymb newtysymb])
           else
              (Table.add symb tysymb seen, newvars, t, [])
          )
       else
          (seen,newvars,t,[])
      )
  | Absyn.ConstantTerm _ -> (seen,newvars,t,[])


(* lh_c : Absyn.atypesymbol Table.SymbolTable.t -> Absyn.aterm -> Absyn.aterm
   given (1) the universally quantified variables in scope and (2) a 
         term representation of a clause to be transformed,
   returns the modified term. *) 
let rec lh_c ctx t = 
  match t with 
  | Absyn.ApplicationTerm(
      Absyn.CurriedApplication(
        Absyn.ConstantTerm(c,_,_),
        Absyn.AbstractionTerm(Absyn.NestedAbstraction(tysymb,body),_)),_)
        when c = Pervasive.allConstant ->
    makeAll tysymb
            (lh_c (Table.add (Absyn.getTypeSymbolSymbol tysymb) tysymb ctx) body )
  | Absyn.ApplicationTerm(
      Absyn.CurriedApplication(
        Absyn.ApplicationTerm(
          Absyn.CurriedApplication(Absyn.ConstantTerm(c,_,_),l),_), r),_)
          when c = Pervasive.implConstant -> 
    let l' = lh_g ctx l in
    let r' = lh_c ctx r in
            makeImp l' r' 
(*  | _ ->
    let (_,newvars,t',eqns) = lh_t ctx Table.empty Table.empty [] t in
    finalize newvars eqns t' *)
  | Absyn.ApplicationTerm(Absyn.CurriedApplication(lf_ty, lf_pt),_) ->
    let (_,newvars,lf_ty',eqns) =
      lh_t ctx Table.empty Table.empty [] lf_ty
    in
    finalize newvars
             eqns
             (Absyn.ApplicationTerm(
                Absyn.CurriedApplication(lf_ty', lf_pt), Errormsg.none))
              
(* lh_g : Absyn.atypesymbol Table.SymbolTable.t -> Absyn.aterm -> Absyn.aterm
   given (1) the universally quantified variables in scope and (2) a 
         term representation of a goal to be transformed,
   returns the modified term. *) 
and lh_g ctx t =
  match t with
  | Absyn.ApplicationTerm(
      Absyn.CurriedApplication(
        Absyn.ConstantTerm(c,_,_),
        Absyn.AbstractionTerm(Absyn.NestedAbstraction(tysymb,body),_)),_)
        when c = Pervasive.allConstant ->
    makeAll tysymb
            (lh_g (Table.add (Absyn.getTypeSymbolSymbol tysymb) tysymb ctx) body )
  | Absyn.ApplicationTerm(
      Absyn.CurriedApplication(
        Absyn.ApplicationTerm(
          Absyn.CurriedApplication(Absyn.ConstantTerm(c,_,_),l),_), r),_)
          when c = Pervasive.implConstant -> 
    let l' = lh_c ctx l in
    let r' = lh_g ctx r in
            makeImp l' r' 
  | _ -> t

  
(* linearize : Absyn.aterm -> Absyn.aterm 
   given a term representation of a clause applies the linear head
   transformation and returns the resulting term. *)

let linearize t = lh_c Table.empty t
