%type nat : type.
%term z : nat.
%term s : nat -> nat.

%type list : type.
%term nil : list.
%term cons : nat -> list -> list.

%type append : {L1:list}{L2:list}{L3:list}type.
%term appNil : {L:list} append nil (L : list ) (L : list ).
%term appCons : {X:nat}{L1:list}{L2:list}{L3:list} (append (L1 : list) (L2:list) (L3:list)) -> (append (cons (X:nat) (L1:list)) (L2:list) (cons (X:nat) (L3:list))).

%type mapFun : {F:nat -> nat}{L1:list}{L2:list}type.
%term mapNil : {F:nat -> nat} mapFun ([X:nat] (F : nat -> nat) (X : nat)) nil nil. 
%term mapCons : {X:nat}{L1:list}{L2:list}{F:nat -> nat}
                  mapFun (F : nat -> nat) (L1 : list) (L2 : list) -> 
                      mapFun (F : nat -> nat) 
                             (cons (X : nat) (L1 : list)) 
                             (cons ((F : nat -> nat) (X : nat)) (L2 : list)).

%type foo : {X:{Y:nat}list -> list} type.
%term bar : {X:list -> ({Y:nat} list)} nat.

%type fun : {F:nat -> nat} type.
%term x1 : fun ([X:nat] z).


%type oty : type.
%term true : oty.
%term imp : oty -> oty -> oty.
%type vdash : {O : oty} type.
%term triv : {P : oty} vdash (imp (P : oty) (P : oty)).
%type somety : {X : vdash (imp lf_true lf_true)} type.
%term someobj : somety (triv true).

%type t : type.
%type c : {A : t} type.
%term a : {X : t} c  (X : t).
%type wrap : {A : {X : t} c (X : t) } type.
%term wraptm : wrap ([X : t] a (X : t)).


%type tp : type.
%term unit : tp.
%term arrow : tp -> tp -> tp.

%type tm : type.
%term empty : tm.
%term app : tm -> tm -> tm.
%term lam : tp -> (tm -> tm) -> tm.

%type of : {X1: tm}{X2 : tp}type.
%term of_empty : of empty unit.
%term of_lam : {T : tp}{T2 : tp}{E : tm -> tm}
               ({X : tm} of (X : tm) (T2 : tp) -> of ((E : tm -> tm) (X : tm)) (T : tp)) -> 
               of (lam (T2 : tp) ([V : tm] (E : tm -> tm) (V : tm))) (arrow (T2 : tp) (T : tp)).
%term of_app : {E1 : tm}{E2 : tm}{T : tp}{T2 : tp}
               of (E1 : tm) (arrow (T2 : tp) (T : tp)) -> of (E2 : tm) (T2 : tp) -> of (app (E1 : tm) (E2 : tm)) (T : tp).